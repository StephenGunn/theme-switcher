#!/usr/bin/env bash

# Theme Switcher for Hyprland
# Uses native themes where available, pywal for fallback

set -e

# Resolve symlinks to find actual script location
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
THEMES_DIR="$PROJECT_DIR/themes"
TEMPLATES_DIR="$PROJECT_DIR/templates"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

# Check if required commands exist
check_dependencies() {
    local missing_deps=()

    for cmd in wal hyprctl rofi jq; do
        if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
        fi
    done

    if [ ${#missing_deps[@]} -gt 0 ]; then
        log_error "Missing dependencies: ${missing_deps[*]}"
        log_info "Install with: sudo pacman -S ${missing_deps[*]}"
        exit 1
    fi
}

# Get list of available themes
get_themes() {
    local themes=()

    if [ ! -d "$THEMES_DIR" ]; then
        log_error "Themes directory not found: $THEMES_DIR"
        exit 1
    fi

    for theme_dir in "$THEMES_DIR"/*; do
        if [ -d "$theme_dir" ] && [ -f "$theme_dir/config.json" ]; then
            themes+=("$(basename "$theme_dir")")
        fi
    done

    printf '%s\n' "${themes[@]}"
}

# Show theme selection menu
select_theme() {
    local selected_theme

    selected_theme=$(get_themes | rofi -dmenu -i -p "Select Theme" -theme-str 'window {width: 400px;}')

    if [ -z "$selected_theme" ]; then
        log_warn "No theme selected"
        exit 0
    fi

    echo "$selected_theme"
}

# Read theme config
read_theme_config() {
    local theme_name="$1"
    local config_file="$THEMES_DIR/$theme_name/config.json"

    if [ ! -f "$config_file" ]; then
        log_error "Config file not found: $config_file"
        exit 1
    fi

    cat "$config_file"
}

# Apply Neovim colorscheme
apply_neovim() {
    local theme_name="$1"
    local config="$2"

    local colorscheme=$(echo "$config" | jq -r '.apps.neovim.colorscheme // empty')
    local background=$(echo "$config" | jq -r '.apps.neovim.background // "dark"')
    local flavor=$(echo "$config" | jq -r '.apps.neovim.flavor // empty')

    if [ -z "$colorscheme" ]; then
        log_warn "No neovim colorscheme specified in theme config"
        return 0
    fi

    log_info "Applying Neovim colorscheme: $colorscheme"

    # Create colorscheme file that will be sourced by neovim
    mkdir -p "$HOME/.config/nvim/lua"
    cat > "$HOME/.config/nvim/lua/current-theme.lua" <<EOF
-- Auto-generated by theme-switcher
-- Do not edit manually

vim.opt.background = "$background"

-- Set colorscheme
vim.cmd.colorscheme("$colorscheme")

-- Catppuccin flavor
if "$flavor" ~= "" and "$colorscheme" == "catppuccin" then
    require("catppuccin").setup({ flavour = "$flavor" })
    vim.cmd.colorscheme("catppuccin")
end

-- Force bufferline to refresh its highlights after colorscheme loads
vim.defer_fn(function()
    pcall(function()
        local bufferline = require("bufferline")
        if bufferline and bufferline.setup then
            -- Trigger a refresh of bufferline highlights
            vim.cmd("doautocmd ColorScheme")
        end
    end)
end, 50)
EOF

    log_success "Neovim colorscheme configured: $colorscheme"

    # Reload all running Neovim instances
    local nvim_sockets=$(find /run/user/$(id -u) -type s -name "nvim.*" 2>/dev/null)
    if [ -n "$nvim_sockets" ]; then
        log_info "Reloading Neovim instances..."
        while IFS= read -r socket; do
            # Send reload command to each Neovim instance
            nvim --server "$socket" --remote-send '<Cmd>lua package.loaded["current-theme"] = nil; require("current-theme")<CR>' 2>/dev/null && \
                log_success "Reloaded Neovim instance: $(basename $socket)" || true
        done <<< "$nvim_sockets"
    fi
}

# Apply Ghostty theme
apply_ghostty() {
    local theme_name="$1"
    local config="$2"

    local ghostty_theme=$(echo "$config" | jq -r '.apps.ghostty.theme // empty')

    if [ -z "$ghostty_theme" ]; then
        log_warn "No ghostty theme specified"
        return 0
    fi

    log_info "Applying Ghostty theme: $ghostty_theme"

    local ghostty_config="$HOME/.config/ghostty/config"
    local ghostty_dotfiles="$HOME/dotfiles/.config/ghostty/config"

    # Update or add theme line in ghostty config
    if [ -f "$ghostty_config" ]; then
        # Remove all existing theme lines (including duplicates)
        sed -i '/^theme\s*=/d' "$ghostty_config"
        # Add new theme at the end
        echo "theme = $ghostty_theme" >> "$ghostty_config"
    fi

    # Also update dotfiles version if it exists
    if [ -f "$ghostty_dotfiles" ]; then
        sed -i '/^theme\s*=/d' "$ghostty_dotfiles"
        echo "theme = $ghostty_theme" >> "$ghostty_dotfiles"
    fi

    # Reload config in all running Ghostty instances using SIGUSR2
    # This triggers reload_config action without killing the processes
    if pgrep -x ghostty &> /dev/null; then
        pkill -SIGUSR2 ghostty
        log_success "Ghostty theme applied and reloaded in all terminals"
    else
        log_success "Ghostty theme applied (will take effect on next launch)"
    fi
}

# Apply Hyprland colors
apply_hyprland() {
    local theme_name="$1"
    local config="$2"

    local colors_file=$(echo "$config" | jq -r '.apps.hyprland.colors_file // empty')

    if [ -z "$colors_file" ]; then
        log_warn "No hyprland colors file specified"
        return 0
    fi

    local source_file="$THEMES_DIR/$theme_name/$colors_file"

    if [ ! -f "$source_file" ]; then
        log_error "Hyprland colors file not found: $source_file"
        return 1
    fi

    log_info "Applying Hyprland colors"

    # Copy to config directory
    mkdir -p "$HOME/.config/hypr"
    cp "$source_file" "$HOME/.config/hypr/colors.conf"

    log_success "Hyprland colors applied"
}

# Apply Hyprpanel theme
apply_hyprpanel() {
    local theme_name="$1"
    local config="$2"

    local theme_file=$(echo "$config" | jq -r '.apps.hyprpanel.theme_file // empty')

    if [ -z "$theme_file" ]; then
        log_warn "No hyprpanel theme specified"
        return 0
    fi

    local hyprpanel_theme="$THEMES_DIR/$theme_name/$theme_file"

    if [ ! -f "$hyprpanel_theme" ]; then
        log_warn "Hyprpanel theme not found: $hyprpanel_theme"
        return 0
    fi

    log_info "Applying Hyprpanel theme"

    if command -v hyprpanel &> /dev/null; then
        if ! pgrep -x "gjs" > /dev/null || ! pgrep -f "hyprpanel" > /dev/null; then
            log_warn "Hyprpanel is not running"
            return 0
        fi

        if hyprpanel useTheme "$hyprpanel_theme" 2>&1; then
            log_success "Hyprpanel theme applied"
        else
            log_warn "Failed to apply Hyprpanel theme"
        fi
    else
        log_warn "hyprpanel command not found"
    fi
}

# Apply Rofi theme
apply_rofi() {
    local theme_name="$1"
    local config="$2"

    local theme_file=$(echo "$config" | jq -r '.apps.rofi.theme_file // empty')

    if [ -z "$theme_file" ]; then
        log_warn "No rofi theme specified"
        return 0
    fi

    local source_file="$THEMES_DIR/$theme_name/$theme_file"

    if [ ! -f "$source_file" ]; then
        log_error "Rofi theme file not found: $source_file"
        return 1
    fi

    log_info "Applying Rofi theme"

    mkdir -p "$HOME/.config/rofi"
    cp "$source_file" "$HOME/.config/rofi/theme.rasi"

    log_success "Rofi theme applied"
}

# Apply GTK theme
apply_gtk() {
    local theme_name="$1"
    local config="$2"

    local gtk_theme=$(echo "$config" | jq -r '.apps.gtk.theme_name // empty')
    local icon_theme=$(echo "$config" | jq -r '.apps.gtk.icon_theme // empty')
    local cursor_theme=$(echo "$config" | jq -r '.apps.gtk.cursor_theme // empty')

    if [ -z "$gtk_theme" ]; then
        log_warn "No GTK theme specified, skipping"
        return 0
    fi

    log_info "Applying GTK theme: $gtk_theme"

    # Update GTK-3.0 settings
    mkdir -p "$HOME/.config/gtk-3.0"
    cat > "$HOME/.config/gtk-3.0/settings.ini" <<EOF
[Settings]
gtk-application-prefer-dark-theme=true
gtk-theme-name=$gtk_theme
gtk-icon-theme-name=$icon_theme
gtk-cursor-theme-name=$cursor_theme
gtk-cursor-theme-size=28
gtk-button-images=true
gtk-decoration-layout=icon:minimize,maximize,close
gtk-enable-animations=true
gtk-font-name=Noto Sans,  10
gtk-menu-images=true
gtk-modules=colorreload-gtk-module:window-decorations-gtk-module
gtk-primary-button-warps-slider=true
gtk-sound-theme-name=ocean
gtk-toolbar-style=3
gtk-xft-dpi=122880
EOF

    # Update GTK-4.0 settings
    mkdir -p "$HOME/.config/gtk-4.0"
    cat > "$HOME/.config/gtk-4.0/settings.ini" <<EOF
[Settings]
gtk-theme-name=$gtk_theme
gtk-icon-theme-name=$icon_theme
gtk-cursor-theme-name=$cursor_theme
gtk-cursor-theme-size=28
gtk-decoration-layout=icon:minimize,maximize,close
gtk-enable-animations=true
gtk-font-name=Noto Sans,  10
gtk-primary-button-warps-slider=true
gtk-sound-theme-name=ocean
gtk-xft-dpi=122880
EOF

    # Update GTK-2.0 settings
    cat > "$HOME/.gtkrc-2.0" <<EOF
gtk-enable-animations=1
gtk-theme-name="$gtk_theme"
gtk-icon-theme-name="$icon_theme"
gtk-cursor-theme-name="$cursor_theme"
gtk-cursor-theme-size=28
gtk-primary-button-warps-slider=1
gtk-toolbar-style=3
gtk-menu-images=1
gtk-button-images=1
gtk-sound-theme-name="ocean"
EOF

    log_success "GTK theme applied: $gtk_theme"

    # Reload GTK applications to pick up new theme
    reload_gtk_apps
}

# Reload GTK applications
reload_gtk_apps() {
    log_info "Applying GTK theme settings..."

    # Update gsettings which GTK apps monitor
    if command -v gsettings &> /dev/null; then
        # Read theme from GTK settings
        local gtk_theme=$(grep "gtk-theme-name=" "$HOME/.config/gtk-3.0/settings.ini" 2>/dev/null | cut -d= -f2)
        local icon_theme=$(grep "gtk-icon-theme-name=" "$HOME/.config/gtk-3.0/settings.ini" 2>/dev/null | cut -d= -f2)
        local cursor_theme=$(grep "gtk-cursor-theme-name=" "$HOME/.config/gtk-3.0/settings.ini" 2>/dev/null | cut -d= -f2)

        if [ -n "$gtk_theme" ]; then
            gsettings set org.gnome.desktop.interface gtk-theme "$gtk_theme" 2>/dev/null
            log_success "Applied GTK theme: $gtk_theme"
        fi

        if [ -n "$icon_theme" ]; then
            gsettings set org.gnome.desktop.interface icon-theme "$icon_theme" 2>/dev/null
            log_success "Applied icon theme: $icon_theme"
        fi

        if [ -n "$cursor_theme" ]; then
            gsettings set org.gnome.desktop.interface cursor-theme "$cursor_theme" 2>/dev/null
        fi
    fi

    # Restart Thunar if running to apply new theme
    if pgrep -x thunar &> /dev/null; then
        log_info "Restarting Thunar to apply new theme..."
        killall thunar 2>/dev/null
        sleep 0.3
        thunar &>/dev/null &
        log_success "Thunar restarted with new theme"
    fi
}

# Apply Yazi theme
apply_yazi() {
    local theme_name="$1"
    local config="$2"

    local yazi_flavor=$(echo "$config" | jq -r '.apps.yazi.flavor // empty')

    if [ -z "$yazi_flavor" ]; then
        log_warn "No yazi flavor specified, skipping"
        return 0
    fi

    log_info "Applying Yazi flavor: $yazi_flavor"

    local yazi_config="$HOME/.config/yazi/theme.toml"
    local yazi_dotfiles="$HOME/dotfiles/.config/yazi/theme.toml"

    # Update theme.toml in both locations
    cat > "$yazi_config" <<EOF
[flavor]
use = "$yazi_flavor"
EOF

    if [ -f "$yazi_dotfiles" ]; then
        cat > "$yazi_dotfiles" <<EOF
[flavor]
use = "$yazi_flavor"
EOF
    fi

    log_success "Yazi flavor applied: $yazi_flavor"
}

# Apply Tmux theme
apply_tmux() {
    local theme_name="$1"
    local config="$2"

    # Check if tmux colors are defined
    local has_tmux_colors=$(echo "$config" | jq -r '.apps.tmux.colors // empty')

    if [ -z "$has_tmux_colors" ]; then
        log_warn "No tmux colors specified, skipping"
        return 0
    fi

    log_info "Applying Tmux theme colors"

    # Extract colors from config
    local bg_dark=$(echo "$config" | jq -r '.apps.tmux.colors.background_dark')
    local fg=$(echo "$config" | jq -r '.apps.tmux.colors.foreground')
    local fg_dim=$(echo "$config" | jq -r '.apps.tmux.colors.foreground_dim')
    local accent=$(echo "$config" | jq -r '.apps.tmux.colors.accent')
    local separator=$(echo "$config" | jq -r '.apps.tmux.colors.separator')
    local inactive_win=$(echo "$config" | jq -r '.apps.tmux.colors.inactive_window')
    local inactive_txt=$(echo "$config" | jq -r '.apps.tmux.colors.inactive_text')
    local active_win=$(echo "$config" | jq -r '.apps.tmux.colors.active_window')
    local clock=$(echo "$config" | jq -r '.apps.tmux.colors.clock')
    local date=$(echo "$config" | jq -r '.apps.tmux.colors.date')

    # Read template and substitute colors
    local template_file="$TEMPLATES_DIR/tmux.conf"

    if [ ! -f "$template_file" ]; then
        log_error "Tmux template not found: $template_file"
        return 1
    fi

    # Generate themed tmux config snippet
    local tmux_colors=$(cat "$template_file" | \
        sed "s/{background_dark}/$bg_dark/g" | \
        sed "s/{foreground}/$fg/g" | \
        sed "s/{foreground_dim}/$fg_dim/g" | \
        sed "s/{accent}/$accent/g" | \
        sed "s/{separator}/$separator/g" | \
        sed "s/{inactive_window}/$inactive_win/g" | \
        sed "s/{inactive_text}/$inactive_txt/g" | \
        sed "s/{active_window}/$active_win/g" | \
        sed "s/{clock}/$clock/g" | \
        sed "s/{date}/$date/g")

    # Update the tmux config by replacing the status bar section
    local tmux_config="$HOME/dotfiles/.tmux/.tmux.conf"

    if [ ! -f "$tmux_config" ]; then
        log_warn "Tmux config not found at $tmux_config"
        return 0
    fi

    # Use sed to replace the status bar section
    # Find start: "# Status Bar Styling"
    # Find end: "# ============" (before Initialize TPM)
    local start_line=$(grep -n "# Status Bar Styling" "$tmux_config" | cut -d: -f1)
    local end_line=$(grep -n "# Initialize TPM" "$tmux_config" | head -1 | cut -d: -f1)

    if [ -z "$start_line" ] || [ -z "$end_line" ]; then
        log_error "Could not find tmux status bar section markers"
        return 1
    fi

    # Decrement end_line to get line before the TPM section
    end_line=$((end_line - 1))

    # Create new config with replaced section
    {
        head -n $((start_line - 1)) "$tmux_config"
        echo "$tmux_colors"
        echo ""
        tail -n +$((end_line + 1)) "$tmux_config"
    } > "$tmux_config.tmp"

    mv "$tmux_config.tmp" "$tmux_config"

    # Reload tmux if running
    if command -v tmux &> /dev/null && tmux list-sessions &> /dev/null; then
        tmux source-file "$tmux_config" 2>/dev/null && \
            log_success "Tmux theme applied and reloaded" || \
            log_success "Tmux theme applied (reload manually with Ctrl-b r)"
    else
        log_success "Tmux theme applied (will take effect on next tmux start)"
    fi
}

# Apply Kvantum theme (Qt applications)
apply_kvantum() {
    local theme_name="$1"
    local config="$2"

    local kvantum_theme=$(echo "$config" | jq -r '.apps.kvantum.theme_name // empty')

    if [ -z "$kvantum_theme" ]; then
        log_warn "No Kvantum theme specified, skipping"
        return 0
    fi

    log_info "Applying Kvantum theme: $kvantum_theme"

    # Create Kvantum config directory
    mkdir -p "$HOME/.config/Kvantum"

    # Write Kvantum configuration
    cat > "$HOME/.config/Kvantum/kvantum.kvconfig" <<EOF
[General]
theme=$kvantum_theme
EOF

    # Ensure Qt uses Kvantum as the style
    # Update environment for current session
    export QT_STYLE_OVERRIDE=kvantum
    export QT_QPA_PLATFORMTHEME=qt5ct

    log_success "Kvantum theme applied: $kvantum_theme"
}

# Apply pywal for fallback apps
apply_pywal() {
    local theme_name="$1"
    local config="$2"

    local colors_file=$(echo "$config" | jq -r '.pywal.colors_file // empty')
    local pywal_apps=$(echo "$config" | jq -r '.pywal.apps[]? // empty')

    if [ -z "$colors_file" ]; then
        log_info "No pywal colors specified, skipping pywal generation"
        return 0
    fi

    local colors_path="$THEMES_DIR/$theme_name/$colors_file"

    if [ ! -f "$colors_path" ]; then
        log_error "Pywal colors file not found: $colors_path"
        return 1
    fi

    log_info "Applying pywal colors for: $pywal_apps"

    # Import pywal colors
    wal --theme "$colors_path" -n -q

    # Copy templates to pywal template directory
    mkdir -p "$HOME/.config/wal/templates"

    # Only copy templates for apps that use pywal
    if echo "$pywal_apps" | grep -q "starship"; then
        cp "$TEMPLATES_DIR/starship.toml" "$HOME/.config/wal/templates/" 2>/dev/null || true
    fi

    if echo "$pywal_apps" | grep -q "dunst"; then
        cp "$TEMPLATES_DIR/dunstrc" "$HOME/.config/wal/templates/" 2>/dev/null || true
    fi

    # Regenerate templates
    wal -R -n -q

    # Link generated configs
    if echo "$pywal_apps" | grep -q "starship"; then
        if [ -f "$HOME/.cache/wal/starship.toml" ]; then
            local starship_dotfiles="$HOME/dotfiles/.config/starship.toml"

            if [ -f "$starship_dotfiles" ] && [ ! -f "$starship_dotfiles.original" ]; then
                cp "$starship_dotfiles" "$starship_dotfiles.original"
            fi

            cp "$HOME/.cache/wal/starship.toml" "$starship_dotfiles"
            log_success "Updated Starship colors"
        fi
    fi

    if echo "$pywal_apps" | grep -q "dunst"; then
        if [ -f "$HOME/.cache/wal/dunstrc" ]; then
            mkdir -p "$HOME/.config/dunst"
            ln -sf "$HOME/.cache/wal/dunstrc" "$HOME/.config/dunst/dunstrc"
            log_success "Linked Dunst config"
        fi
    fi

    log_success "Pywal colors applied"
}

# Reload applications
reload_apps() {
    log_info "Reloading applications..."

    # Reload Hyprland
    # Note: streaming.conf is sourced by hyprland.conf, so streaming mode
    # workspace gaps are preserved automatically through reloads
    if command -v hyprctl &> /dev/null; then
        hyprctl reload &> /dev/null || log_warn "Failed to reload Hyprland"
        log_success "Reloaded Hyprland"
    fi

    # Restart Dunst
    if pgrep -x dunst &> /dev/null; then
        killall dunst 2>/dev/null || true
        dunst &> /dev/null &
        log_success "Restarted Dunst"
    fi

    log_info "Theme changes applied:"
    log_info "  • Ghostty: Reloaded automatically (SIGUSR2)"
    log_info "  • Neovim: Reloaded automatically in all instances"
    log_info "  • Rofi: Will use new theme on next launch"
    log_info "  • Yazi: Restart yazi to see new theme"
    log_info "  • Thunar: Restart to apply GTK theme"
    log_info "  • Starship: Restart shell or open new terminal to see prompt colors"
}

# Main function
main() {
    log_info "Theme Switcher v2.0 (Native Themes)"
    echo ""

    check_dependencies

    # Select theme (or use argument)
    local theme_name="${1:-}"

    if [ -z "$theme_name" ]; then
        theme_name=$(select_theme)
    fi

    if [ ! -d "$THEMES_DIR/$theme_name" ]; then
        log_error "Theme not found: $theme_name"
        log_info "Available themes:"
        get_themes
        exit 1
    fi

    log_info "Applying theme: $theme_name"
    echo ""

    # Read theme config
    local config=$(read_theme_config "$theme_name")

    # Apply native themes
    apply_neovim "$theme_name" "$config"
    apply_ghostty "$theme_name" "$config"
    apply_hyprland "$theme_name" "$config"
    apply_hyprpanel "$theme_name" "$config"
    apply_rofi "$theme_name" "$config"
    apply_gtk "$theme_name" "$config"
    apply_kvantum "$theme_name" "$config"
    apply_yazi "$theme_name" "$config"
    apply_tmux "$theme_name" "$config"

    # Apply pywal for fallback apps
    apply_pywal "$theme_name" "$config"

    # Reload apps
    reload_apps

    # Save current theme name for other scripts (e.g., waypaper-themed)
    echo "$theme_name" > "$HOME/.config/current-theme"

    # Set a random wallpaper from the new theme
    log_info "Selecting random wallpaper from theme..."
    if [ -x "$SCRIPT_DIR/random-wallpaper" ]; then
        "$SCRIPT_DIR/random-wallpaper" || log_warn "Failed to set random wallpaper"
    else
        log_warn "Random wallpaper script not found or not executable"
    fi

    echo ""
    log_success "Theme '$theme_name' applied successfully!"
}

main "$@"
